{
  "name": "parseopt",
  "license": "LGPL 2.1+",
  "author": {
    "name": "Mathias PanzenbÃ¶ck",
    "email": "grosser.meister.morti@gmx.net"
  },
  "version": "1.0.0-2",
  "description": "Advanced command line option parser.",
  "main": "./parseopt",
  "keywords": [
    "option",
    "parser",
    "command-line",
    "cli",
    "terminal",
    "getopt",
    "opts",
    "args"
  ],
  "repository": {
    "type": "hg",
    "url": "http://bitbucket.org/panzi/javascript-utils",
    "web": "http://bitbucket.org/panzi/javascript-utils"
  },
  "readme": "parseopt\n========\n\nParseopt is a command line optionparser loosely inspired by Python's optparse\nmodule. This module was written for node.js but should work with any other\nJavaScript framework. Only when some certain parameters are not provided,\nparseopt uses node.js specific code in order to lookup meaningful defaults.\n\nUsed node.js API:\n\n * `process.argv`: array of strings\n * `process.stdout`: object with a `write` method that accepts a string argument\n * `process.exit`: method that accepts a number argument\n\nSee the demo folder the end of this file for example usage.\n\nAPI Reference\n-------------\n\n### Option Definition ###\n\nOption definitions are objects that specify an option. You use them to specify\nthe name(s), type and severall parameters of an option.\n\nOption types:\n\n * `float`\n * `integer`\n * `string`\n * `boolean`\n * `object`\n * `option`\n * `enum`\n * `flag`\n * `record`\n * `custom`\n\nOption definition object:\n\n\t{\n\t   // Only when passed to the OptionParser constructor:\n\t   name:        string or array\n\t   names:       string or array, alias of name\n\t                Only one of both may be used at the same time.\n\n\t                Names can be long options (e.g. '--foo') and short options\n\t                (e.g. '-f'). The first name is used to identify the option.\n\t                Names musst be unique and may not contain '='.\n\n\t                Short options may be combined when passed to a program. E.g.\n\t                the options '-f' and '-b' can be combined to '-fb'. Only one\n\t                of these combined options may require an argument.\n\n\t                Short options are separated from their arguments by space,\n\t                long options by '='. If a long option requires an argument\n\t                and none is passed using '=' it also uses the next command\n\t                line argument as it's argument (like short options).\n\n\t                If '--' is encountered all remaining arguments are treated as\n\t                arguments and not as options.\n\n\t   // General fields:\n\t   target:      string, per deflault inferred from first name\n\t                This defines the name used in the returned options object.\n\t                Multiple options may have the same target.\n\t   default:     any, default: undefined\n\t                The default value associated with a certain target and is\n\t                overwritten by each new option with the same target.\n\t   type:        string, default: 'string', see below\n\t   required:    boolean, default: false\n\t   redefinable: boolean, default: true\n\t   help:        string, optional\n\t   details:     array, optional\n\t                short list of details shown in braces after the option name\n\t                e.g. integer type options add 'base: '+base if base !== undefined\n\t   metavar:     string or array, per default inferred from type\n\t   onOption:    function (value) -> boolean, optional\n\t                Returning true cancels any further option parsing\n\t                and the parse() method returns null.\n\n\t   // Type: string  (alias: str)\n\t   // Type: boolean (alias: bool)\n\t   // Type: object  (alias: obj)\n\n\t   // Type: integer (alias: int)\n\t   min:         integer, optional\n\t   max:         integer, optional\n\t   NaN:         boolean, default: false\n\t   base:        integer, optional\n\n\t   // Type: float   (alias: number)\n\t   min:         float, optional\n\t   max:         float, optional\n\t   NaN:         boolean, default: false\n\n\t   // Type: flag\n\t   value:       boolean, default: true\n\t   default:     boolean, default: false\n\n\t   // Type: option\n\t   value:       any, per default inferred from first name\n\n\t   // Type: enum\n\t   ignoreCase:  boolean, default: true\n\t   values:      array of possible values or object where the user enters the\n\t                property name of the object and you get the value of the property\n\n\t   // Type: record\n\t   create:      function () -> object, default: Array\n\t   args:        array of type definitions (type part of option definitions)\n\n\t   // Type: custom\n\t   argc:        integer, default: -1\n\t                Number of required arguments.\n\t                -1 means one optional argument.\n\t   parse:       function (string, ...) -> value\n\t   stringify:   function (value) -> string, optional\n\t}\n\n#### Type: `float` ####\n\n**Arguments:** `1`\n\n**Alias:** `number`\n\nParse a `float` option argument. You can optionally specify `min` and `max`\nparameters to the option definition in order to limit the range of allowed\nvalues. Using the boolean `NaN` parameter it can be controlled if `NaN`\nvalues are allowed (default: `false`).\n\nExample:\n\n\tparser.add(['-n','-d','--float'], {\n\t\ttype: 'float',\n\t\tmin: 0\n\t});\n\n#### Type: `integer` ####\n\n**Arguments:** `1`\n\n**Alias:** `int`\n\nParse an `integer` option argument. You can optionally specify `min` and `max`\nparameters to the option definition in order to limit the range of allowed\nvalues. Using the boolean `NaN` parameter it can be controlled if `NaN`\nvalues are allowed (default: `false`). The `base` parameter controls the\nbase of the parsed number. Per default integers are parsed like JavaScript\ninteger literals, meaning a `0x` prefix specifies a hexadecimal number, a\n`0` prefix an octal number and otherwise it is interpreted as a decimal number.\n\nExample:\n\n\tparser.add('--int32', {\n\t\ttype: 'integer',\n\t\tmin: -2147483648,\n\t\tmax: 2147483647,\n\t\tmetavar: 'INT32'\n\t});\n\n#### Type: `string` ####\n\n**Arguments:** `1`\n\n**Alias:** `str`\n\nThis is the default type. It doesn't do any parsing but just passes through\nthe string option argument.\n\nExample:\n\n\tparser.add('--foo', {type: 'string'});\n\n#### Type: `boolean` ####\n\n**Arguments:** `1`\n\n**Alias:** `bool`\n\nParse a `boolean` option argument.\n\nValues accepted as `true` (case is ignored):\n\n * `true`\n * `on`\n * `1`\n * `yes`\n\nValues accepted as `false` (case is ignored):\n\n * `false`\n * `off`\n * `0`\n * `no`\n\nExample:\n\n\tparser.add('--bar', {type: 'boolean'});\n\n#### Type: `object` ####\n\n**Arguments:** `1`\n\n**Alias:** `obj`\n\nParse option argument as JSON string.\n\nExample:\n\n\tparser.add('--obj', {\n\t\ttype: 'object',\n\t\tdefault: {\n\t\t\tfoo: 'bar',\n\t\t\tbaz: [23, 42]\n\t\t}\n\t});\n\n#### Type: `enum` ####\n\n**Arguments:** `1`\n\nWith this option type you can define a list of option `values` as the allowed\noption arguments. The `values` parameter can either be an array of strings or\na object, where the property names are used as the values for the allowed\noption arguments. The value stored to the parsed parameter object will be the\naccording property value. The boolean `ignoreCase` parameter specifies whether\nthe case of the option argument is ignored (default: `true`).\n\nExample:\n\n\tparser.add('--enum1', {\n\t\ttype: 'enum',\n\t\tvalues: ['foo', 'bar', 'baz']\n\t});\n\t\n\tparser.add('--enum2', {\n\t\ttype: 'enum',\n\t\tvalues: {\n\t\t\tfoo: 'FOO',\n\t\t\tbar: [23, 42],\n\t\t\tbaz: null\n\t\t}\n\t});\n\n#### Type: `option` ####\n\n**Arguments:** `0`\n\nWith the `option` type you can specify an option with a fixed value. It makes\nmost sense if you have several options without argument that write the same\n`target`.\n\nSee also: `flag`\n\nExample:\n\n\tparser.add('--opt1', {\n\t\ttype: 'option',\n\t\ttarget: 'what',\n\t\tvalue: 555\n\t});\n\n#### Type: `flag` ####\n\n**Arguments:** `0-1`\n\nLike `option` but only for boolean values. If no option argument is provided\nthe value specified by the `value` parameter is used.\n\nExample:\n\n\tparser.add('--use-something', {type: 'flag'});\n\n#### Type: `record` ####\n\n**Arguments:** `*`\n\nA `record` option accepts several option arguments. How many and which types\nis specified through the `args` parameter. This parameter accepts an array of\noption definitions (some parameters of these option definitions are ignored:\n`name`, `default`, `required`, `redefinable`, `help`, `details`, `onOption`).\nThe type ot the record itself can be provided through the `create` parameter\n(function, default: Array).\n\nExample:\n\n\tparser.add('--record', {\n\t\ttype: 'record',\n\t\tdefault: ['bla', [10, 'bleh']],\n\t\targs: [\n\t\t\t{type: 'string'},\n\t\t\t{type: 'record', args: [\n\t\t\t\t{type: 'integer'},\n\t\t\t\t{type: 'string'},\n\t\t\t]}\n\t\t]\n\t});\n\t\n\tparser.add('--named', {\n\t\ttype: 'record',\n\t\tcreate: Object,\n\t\tdefault: {a: 0.5, b: 300, c: 'bla'},\n\t\targs: [\n\t\t\t{type: 'float',   target: 'a'},\n\t\t\t{type: 'integer', target: 'b'},\n\t\t\t{type: 'string',  target: 'c'}\n\t]});\n\n#### Type: `custom` ####\n\n**Arguments:** `*`\n\nExample:\n\n\tparser.add('--b64', {\n\t\ttype: 'custom',\n\t\targc: 1,\n\t\tmetavar: 'BASE64-STRING',\n\t\tparse: function (s) {\n\t\t\treturn new Buffer(s, 'base64');\n\t\t},\n\t\tstringify: function (buffer) {\n\t\t\treturn buffer.toString('base64');\n\t\t},\n\t\thelp: 'Pass binary data as a base64 encoded string.'\n\t});\n\n### OptionParser ###\n\n#### Constructor ####\n\n**Arguments:**\n\n * `params`: object, optional\n\n\n##### params #####\n\n\t{\n\t   minargs: integer, optional\n\t   maxargs: integer, optional\n\t   program: string, per default inferred from process.argv\n\t   strings: object, optional\n\t            Table of strings used in the output. See below.\n\t   options: array, optional\n\t            Array of option definitions. See below.\n\t}\n\n##### strings #####\n\n\t{\n\t   help:      string, default: 'No help available for this option.'\n\t   usage:     string, default: 'Usage'\n\t   options:   string, default: 'OPTIONS'\n\t   arguments: string, default: 'ARGUMENTS'\n\t   required:  string, default: 'required'\n\t   default:   string, default: 'default'\n\t   base:      string, default: 'base'\n\t   metavars:  object, optional\n\t              Table of default metavar names per type.\n\t              Per default the type name in capital letters or derived\n\t              from the possible values.\n\t}\n\n#### Properties ####\n\nDon't modifiy the properties unless you really know what you are doing.\n\n##### optionsPerName #####\n\n**Type:** `Object`\n\nMap of option definitions. Option definitions may occur multiple times when\nthere are name aliases.\n\n##### options #####\n\n**Type:** `Array`\n\nArray of option definitions.\n\n##### defaultValues #####\n\n**Type:** `Object`\n\nMap of default values.\n\n#### Methods ####\n\n##### parse #####\n\n**Arguments:** \n\n * `args`: array of strings, default: `process.argv`\n\n##### add #####\n\n**Arguments:**\n\n * `names`: string or array of strings, optional\n * `optdef`: option definition, optional\n\n##### error #####\n\n**Arguments:**\n\n * `msg`: string\n * `out`: `WriteStream`, default: `process.stdout`\n \n##### usage #####\n\n**Arguments:**\n\n * `help`: string\n * `out`: `WriteStream`, default: `process.stdout`\n",
  "_id": "parseopt@1.0.0-2",
  "dist": {
    "shasum": "318c5e89c1041e538cf02f7d46880a1c63514c7b"
  },
  "_from": "parseopt@>=1.0.0"
}
